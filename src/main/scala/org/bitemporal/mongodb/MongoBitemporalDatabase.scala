package org.bitemporal.mongodb

import org.bitemporal.BitemporalDatabase
import com.mongodb.MongoClient
import org.bitemporal.Temporal
import org.bitemporal.Period
import org.mongojack.JacksonDBCollection
import java.util.Date
import org.bson.types.ObjectId
import org.mongojack.WriteResult
import com.fasterxml.jackson.annotation.JsonProperty
import org.bitemporal.BitemporalDatabase
import org.bitemporal.BitemporalContext
import com.mongodb.BasicDBObject
import com.mongodb.WriteConcern
import com.mongodb.DBObject
import org.mongojack.DBQuery.Query
import org.mongojack.DBQuery
import org.mongojack.DBCursor

/**
 * While most relational databases have sequences to generate logical Ids for applications, 
 * mongodb does not have sequences. Sequences could be modeled as described here :
 * 
 * http://docs.mongodb.org/manual/tutorial/create-an-auto-incrementing-field/#auto-increment-optimistic-loop
 * 
 * Yet the use of sequences in distributed databases is discouraged, because it does not scale well.
 * 
 * We thus prefer to use the objectId generated by mongodb for the first inserted version of an object
 * as the logicalId.  
 * 
 * When storing the first version of an object, we must store it twice:
 * 
 * Once for letting mongodb generate the unique ID, then for setting its logical id to the same value 
 * as its _id field.
 * 
 */

class MongoBitemporalDatabase(
  host: String = "localhost",
  port: Int = 27017,
  dbname: String = "test") {

  val client = new MongoClient(host, port)
  val db = client.getDB(dbname)

  private def getCollection[T >: Null](t: T): JacksonDBCollection[MongoTemporal[T, ObjectId], ObjectId] = {
    val collectionName = t.getClass.toString.replaceAll("\\.", "_").replace("class ", "");
    val collection = db.getCollection(collectionName)
    JacksonDBCollection.wrap(collection, classOf[MongoTemporal[T, ObjectId]], classOf[ObjectId]);
  }

  /**
   * Store an object within mongodb. We use the objectId generated by mongodb as the logicalId of the object.
   * Subsequent inserts for this logicalId will of course get different objectIds.
   */
  def store[T >: Null](t: T, when: Date, validity: Period): ObjectId = {
    val coll : JacksonDBCollection[MongoTemporal[T, ObjectId], ObjectId] = this.getCollection(t);
    val result: WriteResult[MongoTemporal[T, ObjectId], ObjectId] = coll.insert(new MongoTemporal[T, ObjectId](t, validity))
    val logicalId : Option[ObjectId] = Some(result.getSavedId())
    val saved : MongoTemporal[T, ObjectId] = result.getSavedObject()
    saved.logicalId = result.getSavedId()
    val query : Query = DBQuery.is("_id", result.getSavedId());
    coll.update(query, saved, false, false, WriteConcern.UNACKNOWLEDGED);
    saved.logicalId
  }

  def store[T](t: T) : ObjectId = { this.store(t, new Date(), new Period) }
  def store[T](t: T, when: Date) : ObjectId = { this.store(t, when, new Period) }
  def store[T >: Null](t: T, validity: Period) : ObjectId = { this.store(t, new Date(), validity) }

  def tableCount(): Int = { 1 }
  def countInstances[T](logicalId: ObjectId, t: T): Int = { 1 }
  def countMongoTemporal[T](t: T): Int = { 1 }
  def countTechnical[T](t: T): Int = { 1 }
  def countLogical[T](t: T): Int = { 1 }
  def updateLogical[T](logicalId: ObjectId, instance: T, validity: Period) = {}
  def updateLogical[T](logicalId: ObjectId, instance: T, validity: Period, date: Date) = {}
  // drop an object together with all its temporal and technical versions
  def dropLogical[T](logicalId: ObjectId, t: T) = {}
  def countCollections(): Int = { 1 }
  def findLogical[T >: Null](t: T, id: ObjectId): Option[MongoTemporal[T, ObjectId]] =
    findLogical(t, id, new BitemporalContext(new Date(), new Date()))

  def findLogical[T >: Null](t: T, id: ObjectId, context: BitemporalContext): Option[MongoTemporal[T, ObjectId]] = {
    val coll = this.getCollection(t);
    val cursor: DBCursor[MongoTemporal[T, ObjectId]] = coll.find().lessThan("vPeriod.from", context.validDate).greaterThan("vPeriod.to", context.validDate)
    if (cursor.hasNext()) return Some(cursor.next())
    return None
  }

  def clearDatabase() = {}

}